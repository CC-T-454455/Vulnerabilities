# Unrestricted File Upload Vulnerability Leading to RCE in FastapiAdmin

> **Software and Affected Version:** [FastapiAdmin](https://github.com/fastapiadmin/FastapiAdmin) ≤ 2.2.0

## Vulnerability files

-   `/backend/app/api/v1/module_common/file/controller.py`
-   `/backend/app/api/v1/module_common/file/service.py`
-   `/backend/app/utils/upload_util.py`

## Description

An unrestricted file upload vulnerability in [FastapiAdmin](https://github.com/fastapiadmin/FastapiAdmin) ≤ 2.2.0 at `/api/v1/common/file/upload` allows authenticated users with the `module_common:file:upload` permission to write arbitrary files to the server filesystem and, when combined with the scheduled task APIs, achieve remote code execution. The upload routine trusts the Content-Type header to infer allowed extensions, does not validate or canonicalize file paths, and writes files directly under the upload directory, enabling attackers to bypass extension checks (e.g., upload a Python script disguised as an SVG), persist it, and trigger execution via task scheduling. Mitigations include enforcing server-side content inspection (validate file magic bytes), deriving extensions from content not headers, normalizing and restricting saved paths to a safe upload directory with no execute permissions, generating safe randomized filenames, imposing strict allowlists for upload types, scanning uploads for dangerous content, and requiring least-privilege access controls and audit logging for upload and task APIs.

## Code Analysis

In `/backend/app/api/v1/module_common/file/controller.py`:

```py
@FileRouter.post(
    "/upload",
    summary="上传文件",
    description="上传文件",
    response_model=ResponseSchema[dict],
    dependencies=[Depends(AuthPermission(["module_common:file:upload"]))],
)
async def upload_controller(
    file: UploadFile,
    request: Request,
) -> JSONResponse:
    """
    上传文件

    参数:
    - file (UploadFile): 上传的文件
    - request (Request): 请求对象

    返回:
    - JSONResponse: 包含上传文件详情的JSON响应
    """
    result_dict = await FileService.upload_service(base_url=str(request.base_url), file=file)
    log.info(f"上传文件成功 {result_dict}")
    return SuccessResponse(data=result_dict, msg="上传文件成功")
```

In `/backend/app/api/v1/module_common/file/service.py`:

```py
class FileService:

    # ...

    @classmethod
    async def upload_service(
        cls, base_url: str, file: UploadFile, upload_type: str = "local"
    ) -> dict:
        """
        上传文件。

        参数:
        - base_url (str): 基础访问 URL。
        - file (UploadFile): 上传文件对象。
        - upload_type (str): 上传类型，'local' 或 'oss'，默认 'local'。

        返回:
        - Dict: 上传响应字典。

        异常:
        - CustomException: 当未选择文件或上传类型错误时抛出。
        """
        if upload_type == "local":
            filename, filepath, file_url = await UploadUtil.upload_file(
                file=file, base_url=base_url
            )
        else:
            raise CustomException(msg="上传类型错误")

        return UploadResponseSchema(
            file_path=f"{filepath}",
            file_name=filename,
            origin_name=file.filename,
            file_url=f"{file_url}",
        ).model_dump()
```

In `/backend/app/utils/upload_util.py`:

```py
class UploadUtil:

    # ...

    @staticmethod
    def check_file_extension(file: UploadFile) -> bool:
        """
        检查文件后缀是否合法。

        参数:
        - file (UploadFile): 上传的文件对象。

        返回:
        - bool: 文件后缀是否合法。

        异常:
        - CustomException: 文件类型不支持时抛出。
        """
        if file.content_type:
            file_extension = mimetypes.guess_extension(file.content_type)
            if file_extension and file_extension in settings.ALLOWED_EXTENSIONS:
                return True
            raise CustomException(msg="文件类型不支持")
        raise CustomException(msg="文件类型不支持")

    # ...

    @classmethod
    async def upload_file(cls, file: UploadFile, base_url: str) -> tuple[str, Path, str]:
        """
        文件上传。

        参数:
        - file (UploadFile): 上传的文件对象。
        - base_url (str): 基础 URL。

        返回:
        - tuple[str, Path, str]: (文件名, 文件路径, 文件 URL)。

        异常:
        - CustomException: 当文件类型不支持或大小超限时抛出。
        """
        # 文件校验
        if not all([
            cls.check_file_extension(file),
            cls.check_file_size(file),
        ]):
            raise CustomException(msg="文件类型或大小不合法")

        try:
            # 构建完整的目录路径
            dir_path = settings.UPLOAD_FILE_PATH.joinpath(datetime.now().strftime("%Y/%m/%d"))
            dir_path.mkdir(parents=True, exist_ok=True)

            filename = ""
            # 生成文件名并保存
            if file.filename:
                filename = cls.generate_file_name(file.filename)
            filepath = dir_path.joinpath(filename)
            file_url = urljoin(base_url, str(filepath))
            # filepath.mkdir(parents=True, exist_ok=True)

            # 分块写入文件
            chunk_size = 8 * 1024 * 1024  # 8MB chunks
            async with aiofiles.open(filepath, "wb") as f:
                while chunk := await file.read(chunk_size):
                    await f.write(chunk)

            # 返回相对路径
            return filename, filepath, file_url

        except Exception as e:
            log.error(f"文件上传失败: {e}")
            raise CustomException(msg=f"文件上传失败: {e}")
```

The developers did not validate the file path and did not validate the consistency between file content, file extension, and the Content-Type (MIME) header, allowing attackers to bypass `check_file_extension` by spoofing the Content-Type header. It should be noted that this vulnerability and the other two vulnerabilities are based on the same principle, only the entry points differ:

-   [Unrestricted File Upload](https://github.com/CC-T-454455/Vulnerabilities/tree/master/fastapi-admin/vulnerability-4): `/api/v1/system/param/upload`
-   [Unrestricted File Upload](https://github.com/CC-T-454455/Vulnerabilities/tree/master/fastapi-admin/vulnerability-5): `/api/v1/system/user/current/avatar/upload`

## Proof of Concept

Upload a malicious Python script disguised as an SVG image using the following request, and remember the returned filename.

![](./assets/rce-1.png)

Create a scheduled task using the following request, where the `func` field contains the uploaded filename with `.job` appended, and the `args` field contains the malicious command to be executed.

![](./assets/rce-2.png)

Trigger the scheduled task directly using the ID returned by the task creation request above, thus executing the malicious command.

![](./assets/rce-3.png)

By combining this with an [unrestricted file download vulnerability](https://github.com/CC-T-454455/Vulnerabilities/tree/master/fastapi-admin/vulnerability-2), command execution outputs can be obtained.

![](./assets/rce-4.png)
